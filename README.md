ЛАБРАТОРНА НОМЕР 1
Варіант 1
Зеник подарував Марічці ділянку городу розміром n на m, поділену на клітинки розміром 1 на 1 метр. У кожній клітинці Марічка посадила гарбузи, щоб дарувати їх залицальникам. Марічка почала садити гарбузи починаючи із верхньої лівої, і при досягненні правої межі - розверталась і рухалась справа наліво, як вказано в прикладі для m x n, де m - кількість рядків, а n - кількість стовпців:

1 2 3 4 8 7 6 5 9 10 11 12 16 15 14 13

Для садіння Марічка вирішила використати робота-садівника, який садить в кожну клітинку задану кількість зернят, які слід вказати як одномірний масив m x n. Якщо Марічка хоче посадити таку кількість гарбузів

1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

Тоді роботу необхідно подати на всід таку послідовність (маршрут робота не незмінним):

1 2 3 4 8 7 6 5 9 10 11 12 16 15 14 13

Реалізуйте алгоритм, який отримає на вхід масив розміром m та n, в кожній клітинці якого знаходиться бажана кількість гарбузів та поверне одномірний масив, скільки зернин має висаджувати робот при руху згідно маршруту, вказаного в цій задчі (маршрут є незмінним)


Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest . Ваш тести мають перевірити роботу алгоритму при значеннях m == n == 5, m =2, n =4, n = 1, m = 6

ЛАБОРАТОРНА НОМЕР 2

Love

Андрій закоханий у Ілону. Вони вирішили провести День святого Валентина разом в Ашані, але Андрій, як ми всі знаємо, дуже зайнятий на роботі, тому він не зміг прийти. Тепер якраз Ілона знову наповнена гнівом і готова його вбити. Але є щось, що ви можете зробити.

Андрій розповідає Ілоні, що він програміст-початківець і, як правило, зайнятий вирішенням важливих проблем на проекті. Тож Ілона вирішує перевірити його алгоритмічні навички. Вона пише масив N цілих чисел. Вона дає йому число P і запитує, чи може він знайти три ( тільки три) цілих числа Ai Aj Ak (i ≠ j ≠ k) в масиві, сума якого дорівнює числу P, тобто

Ai + Aj + Ak  = P

Отже, чим швидше Андрій скаже відповідь “Такі числа є” або “Таких чисел немає” тим швидше він отримає поцілунок

Вхідні дані: Масив цілих чисел A1, A2 A3 ……………. AN  Р - Шукане число 

Обмеження 3<= N <= 1000 1<= Ai <= 10^9 де 1<= i <=N 1<= P <= 3*10^9

Приклад

Input 1 2 3 6

Output True

Для перевірки виконання роботи реалізованого алгоритму слід використати бібліотеку unittest та перевірити роботу вашої функції на прикладах, наведених вище

ЛАБОРАТОРНА №3
Для заданого бінарного дерева та конкретної вершини в цьому дереві реалізуйте функцію пошуку наступного елемента під час серединного проходу (in-order traversal). Наступник - це вузол, який має значення більше за заданий вузол і знаходиться найближче до нього при серединному обході.

Нехай у вас задане бінарне дерево такого вигляду:

    10
   /  \
  5    15
 / \     \
3   7    20
         /
        12

Для вершини зі значенням 7, наступник - це вузол зі значенням 10.

Функція отримує на вхід корінь бінарного дерева та вершину, для якої потрібно знайти наступника.

Клас, який описує бінарне дерево (та будь який вузол дерева) має вигляд:

# This is the class of the input binary tree.
class BinaryTree:
    def __init__(self, value, left=None, right=None, parent=None):
        self.value = value
        self.left = left
        self.right = right
        self.parent = parent
Ваша функція має мати такий вигляд:

def find_successor(tree: BinaryTree, node: BinaryTree) -> BinaryTree:
Реалізація даної задачі не вимагає написання коду вставки чи виділення елементів з бінарного дерева. У тесті ви можете створити достатню кількість елементів класу BinaryTree наступним чином:

root = BinaryTree(3)
root.left = BinaryTree(9)
root.right = BinaryTree(20)

ЛАБОРАТОРНА №4

Реалізуйте структуру даних "черга з пріоритетами" на основі бінарної купи binary heap, в якому кожен батьківський елемент має вищий пріоритет, ніж пріоритети його дітей.

Якщо у двох елементів однаковий пріоритет, то батьківський елемент може мати пріоритет, ідентичний пріоритету одного або обох його дітей.

Операції, які підтримує ваша черга:

Вставка елемента з заданим значенням та пріоритетом до черги.
Видалення та повернення елемента з найвищим пріоритетом з черги.
Перегляд черги без її зміни.
Для реалізації такої черги з пріоритетами слід використати окремий клас Node, де кожен елемент буде мати два поля: значення та пріоритет. При вставці елемента до черги, його потрібно розмістити у відповідному порядку з урахуванням пріоритету. При видаленні елемента з найвищим пріоритетом, на його місце слід розмістити елемент з наступним найвищим пріоритетом.

Назва файлу реалізації - heap_based_priority_queue.py

ЛАБОРАТОРНА №5

Варіант 1 - Лабіринт
Дано лабіринт у формі двійкової прямокутної матриці, знайдіть найкоротший шлях у лабіринті від заданої точки до вказаного пункту призначення.

Шлях можна побудувати лише з використанням комірок, які містіть 1.  В будь-який момент ми можемо рухатися лише на один крок в одному з чотирьох напрямків:
Go Top: (x, y) ——> (x – 1, y)
Go Left: (x, y) ——> (x, y – 1)
Go Down: (x, y) ——> (x + 1, y)
Go Right: (x, y) ——> (x, y + 1)

Наприклад, розглянемо наступну двійкову матрицю. Якщо початкова точка  має координати (0, 0), а  пункт призначення = (7, 5), тоді найкоротший шлях від джерела до пункту призначення має довжину 12

 [ 1  1  1  1  1  0  0  1  1  1 ]
 [ 0  1  1  1  1  1  0  1  0  1 ]
 [ 0  0  1  0  1  1  1  0  0  1 ]
 [ 1  0  1  1  1  0  1  1  0  1 ]
 [ 0  0  0  1  0  0  0  1  0  1 ]
 [ 1  0  1  1  1  0  0  1  1  0 ]
 [ 0  0  0  0  1  0  0  1  0  1 ]
 [ 0  1  1  1  1  1  1  1  0  0 ]
 [ 1  1  1  1  1  0  0  1  1  1 ]
 [ 0  0  1  0  0  1  1  0  0  1 ]

Вхідні дані містяться у файлі input.txt у форматі:
0, 0 #початкова точка
7, 5 #точка призначення
10,10 # кількість рядків та стовпчиків у матриці
 [ 1  1  1  1  1  0  0  1  1  1 ]
 [ 0  1  1  1  1  1  0  1  0  1 ]
 [ 0  0  1  0  1  1  1  0  0  1 ]
 [ 1  0  1  1  1  0  1  1  0  1 ]
 [ 0  0  0  1  0  0  0  1  0  1 ]
 [ 1  0  1  1  1  0  0  1  1  0 ]
 [ 0  0  0  0  1  0  0  1  0  1 ]
 [ 0  1  1  1  1  1  1  1  0  0 ]
 [ 1  1  1  1  1  0  0  1  1  1 ]
 [ 0  0  1  0  0  1  1  0  0  1 ]


Результуючий файл має містити значення найкоротшого шляху від початкової точки до точки призначення

